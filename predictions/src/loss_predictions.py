####################################################################################################################################################################################
####################################################################################################################################################################################
####################################################################################################################################################################################
from tensorflow.keras import backend as K

import tensorflow as tf
import numpy as np

import keras

import sys

####################################################################################################################################################################################
####################################################################################################################################################################################
####################################################################################################################################################################################
@keras.saving.register_keras_serializable(package='MyLossFunctionsA', name='customMSE')
def customMSE(y_true, y_pred):

  loss = K.mean((y_true - y_pred) ** 2)

  return loss

####################################################################################################################################################################################
####################################################################################################################################################################################
####################################################################################################################################################################################
@keras.saving.register_keras_serializable(package='MyLossFunctionsB', name='customBGamma')
def customBGamma(y_true, y_pred):

  dim_target = y_true.shape[1]

  p     = y_pred[:, :dim_target]
  shape = K.exp(y_pred[:, dim_target:(dim_target*2)])
  scale = K.exp(y_pred[:, (dim_target*2):])

  bool_rain = K.cast(K.greater(y_true, 0), tf.float32)

  epsilon = 0.000001
  noRainCase = (1 - bool_rain) * K.log(1 - p + epsilon)
  rainCase = bool_rain * (K.log(p + epsilon) + (shape - 1) * K.log(y_true + epsilon) - shape * K.log(scale + epsilon) -  tf.math.lgamma(shape + epsilon) - y_true / (scale + epsilon))

  loss = -K.mean(noRainCase + rainCase)

  return loss
